/*! jQuery Validation Plugin - v1.11.1 - 3/22/2013\n* https://github.com/jzaefferer/jquery-validation
* Copyright (c) 2013 JÃ¶rn Zaefferer; Licensed MIT */(function (t) {
  t.extend(t.fn, {
    validate(e) { if (!this.length) return e && e.debug && window.console && console.warn("Nothing selected, can't validate, returning nothing."), void 0; let i = t.data(this[0], 'validator'); return i || (this.attr('novalidate', 'novalidate'), i = new t.validator(e, this[0]), t.data(this[0], 'validator', i), i.settings.onsubmit && (this.validateDelegate(':submit', 'click', (e) => { i.settings.submitHandler && (i.submitButton = e.target), t(e.target).hasClass('cancel') && (i.cancelSubmit = !0), void 0 !== t(e.target).attr('formnovalidate') && (i.cancelSubmit = !0); }), this.submit((e) => { function s() { let s; return i.settings.submitHandler ? (i.submitButton && (s = t("<input type='hidden'/>").attr('name', i.submitButton.name).val(t(i.submitButton).val()).appendTo(i.currentForm)), i.settings.submitHandler.call(i, i.currentForm, e), i.submitButton && s.remove(), !1) : !0; } return i.settings.debug && e.preventDefault(), i.cancelSubmit ? (i.cancelSubmit = !1, s()) : i.form() ? i.pendingRequest ? (i.formSubmitted = !0, !1) : s() : (i.focusInvalid(), !1); })), i); }, valid() { if (t(this[0]).is('form')) return this.validate().form(); let e = !0; const i = t(this[0].form).validate(); return this.each(function () { e = e && i.element(this); }), e; }, removeAttrs(e) { const i = {}; const s = this; return t.each(e.split(/\s/), (t, e) => { i[e] = s.attr(e), s.removeAttr(e); }), i; }, rules(e, i) { const s = this[0]; if (e) { const r = t.data(s.form, 'validator').settings; const n = r.rules; const a = t.validator.staticRules(s); switch (e) { case 'add': t.extend(a, t.validator.normalizeRule(i)), delete a.messages, n[s.name] = a, i.messages && (r.messages[s.name] = t.extend(r.messages[s.name], i.messages)); break; case 'remove': if (!i) return delete n[s.name], a; var u = {}; return t.each(i.split(/\s/), (t, e) => { u[e] = a[e], delete a[e]; }), u; } } let o = t.validator.normalizeRules(t.extend({}, t.validator.classRules(s), t.validator.attributeRules(s), t.validator.dataRules(s), t.validator.staticRules(s)), s); if (o.required) { const l = o.required; delete o.required, o = t.extend({ required: l }, o); } return o; },
  }), t.extend(t.expr[':'], { blank(e) { return !t.trim(`${t(e).val()}`); }, filled(e) { return !!t.trim(`${t(e).val()}`); }, unchecked(e) { return !t(e).prop('checked'); } }), t.validator = function (e, i) { this.settings = t.extend(!0, {}, t.validator.defaults, e), this.currentForm = i, this.init(); }, t.validator.format = function (e, i) { return arguments.length === 1 ? function () { const i = t.makeArray(arguments); return i.unshift(e), t.validator.format.apply(this, i); } : (arguments.length > 2 && i.constructor !== Array && (i = t.makeArray(arguments).slice(1)), i.constructor !== Array && (i = [i]), t.each(i, (t, i) => { e = e.replace(RegExp(`\\{${t}\\}`, 'g'), () => i); }), e); }, t.extend(t.validator, {
    defaults: {
      messages: {}, groups: {}, rules: {}, errorClass: 'error', validClass: 'valid', errorElement: 'label', focusInvalid: !0, errorContainer: t([]), errorLabelContainer: t([]), onsubmit: !0, ignore: ':hidden', ignoreTitle: !1, onfocusin(t) { this.lastActive = t, this.settings.focusCleanup && !this.blockFocusCleanup && (this.settings.unhighlight && this.settings.unhighlight.call(this, t, this.settings.errorClass, this.settings.validClass), this.addWrapper(this.errorsFor(t)).hide()); }, onfocusout(t) { this.checkable(t) || !(t.name in this.submitted) && this.optional(t) || this.element(t); }, onkeyup(t, e) { (e.which !== 9 || this.elementValue(t) !== '') && (t.name in this.submitted || t === this.lastElement) && this.element(t); }, onclick(t) { t.name in this.submitted ? this.element(t) : t.parentNode.name in this.submitted && this.element(t.parentNode); }, highlight(e, i, s) { e.type === 'radio' ? this.findByName(e.name).addClass(i).removeClass(s) : t(e).addClass(i).removeClass(s); }, unhighlight(e, i, s) { e.type === 'radio' ? this.findByName(e.name).removeClass(i).addClass(s) : t(e).removeClass(i).addClass(s); },
    },
    setDefaults(e) { t.extend(t.validator.defaults, e); },
    messages: {
      required: 'This field is required.', remote: 'Please fix this field.', email: 'Please enter a valid email address.', url: 'Please enter a valid URL.', date: 'Please enter a valid date.', dateISO: 'Please enter a valid date (ISO).', number: 'Please enter a valid number.', digits: 'Please enter only digits.', creditcard: 'Please enter a valid credit card number.', equalTo: 'Please enter the same value again.', maxlength: t.validator.format('Please enter no more than {0} characters.'), minlength: t.validator.format('Please enter at least {0} characters.'), rangelength: t.validator.format('Please enter a value between {0} and {1} characters long.'), range: t.validator.format('Please enter a value between {0} and {1}.'), max: t.validator.format('Please enter a value less than or equal to {0}.'), min: t.validator.format('Please enter a value greater than or equal to {0}.'),
    },
    autoCreateRanges: !1,
    prototype: {
      init() { function e(e) { const i = t.data(this[0].form, 'validator'); const s = `on${e.type.replace(/^validate/, '')}`; i.settings[s] && i.settings[s].call(i, this[0], e); } this.labelContainer = t(this.settings.errorLabelContainer), this.errorContext = this.labelContainer.length && this.labelContainer || t(this.currentForm), this.containers = t(this.settings.errorContainer).add(this.settings.errorLabelContainer), this.submitted = {}, this.valueCache = {}, this.pendingRequest = 0, this.pending = {}, this.invalid = {}, this.reset(); const i = this.groups = {}; t.each(this.settings.groups, (e, s) => { typeof s === 'string' && (s = s.split(/\s/)), t.each(s, (t, s) => { i[s] = e; }); }); const s = this.settings.rules; t.each(s, (e, i) => { s[e] = t.validator.normalizeRule(i); }), t(this.currentForm).validateDelegate(":text, [type='password'], [type='file'], select, textarea, [type='number'], [type='search'] ,[type='tel'], [type='url'], [type='email'], [type='datetime'], [type='date'], [type='month'], [type='week'], [type='time'], [type='datetime-local'], [type='range'], [type='color'] ", 'focusin focusout keyup', e).validateDelegate("[type='radio'], [type='checkbox'], select, option", 'click', e), this.settings.invalidHandler && t(this.currentForm).bind('invalid-form.validate', this.settings.invalidHandler); },
      form() { return this.checkForm(), t.extend(this.submitted, this.errorMap), this.invalid = t.extend({}, this.errorMap), this.valid() || t(this.currentForm).triggerHandler('invalid-form', [this]), this.showErrors(), this.valid(); },
      checkForm() { this.prepareForm(); for (let t = 0, e = this.currentElements = this.elements(); e[t]; t++) this.check(e[t]); return this.valid(); },
      element(e) { e = this.validationTargetFor(this.clean(e)), this.lastElement = e, this.prepareElement(e), this.currentElements = t(e); const i = this.check(e) !== !1; return i ? delete this.invalid[e.name] : this.invalid[e.name] = !0, this.numberOfInvalids() || (this.toHide = this.toHide.add(this.containers)), this.showErrors(), i; },
      showErrors(e) { if (e) { t.extend(this.errorMap, e), this.errorList = []; for (const i in e) this.errorList.push({ message: e[i], element: this.findByName(i)[0] }); this.successList = t.grep(this.successList, (t) => !(t.name in e)); } this.settings.showErrors ? this.settings.showErrors.call(this, this.errorMap, this.errorList) : this.defaultShowErrors(); },
      resetForm() { t.fn.resetForm && t(this.currentForm).resetForm(), this.submitted = {}, this.lastElement = null, this.prepareForm(), this.hideErrors(), this.elements().removeClass(this.settings.errorClass).removeData('previousValue'); },
      numberOfInvalids() { return this.objectLength(this.invalid); },
      objectLength(t) { let e = 0; for (const i in t)e++; return e; },
      hideErrors() { this.addWrapper(this.toHide).hide(); },
      valid() { return this.size() === 0; },
      size() { return this.errorList.length; },
      focusInvalid() { if (this.settings.focusInvalid) try { t(this.findLastActive() || this.errorList.length && this.errorList[0].element || []).filter(':visible').focus().trigger('focusin'); } catch (e) {} },
      findLastActive() { const e = this.lastActive; return e && t.grep(this.errorList, (t) => t.element.name === e.name).length === 1 && e; },
      elements() {
        const e = this; const i = {}; return t(this.currentForm).find('input, select, textarea').not(':submit, :reset, :image, [disabled]').not(this.settings.ignore)
          .filter(function () { return !this.name && e.settings.debug && window.console && console.error('%o has no name assigned', this), this.name in i || !e.objectLength(t(this).rules()) ? !1 : (i[this.name] = !0, !0); });
      },
      clean(e) { return t(e)[0]; },
      errors() { const e = this.settings.errorClass.replace(' ', '.'); return t(`${this.settings.errorElement}.${e}`, this.errorContext); },
      reset() { this.successList = [], this.errorList = [], this.errorMap = {}, this.toShow = t([]), this.toHide = t([]), this.currentElements = t([]); },
      prepareForm() { this.reset(), this.toHide = this.errors().add(this.containers); },
      prepareElement(t) { this.reset(), this.toHide = this.errorsFor(t); },
      elementValue(e) { const i = t(e).attr('type'); const s = t(e).val(); return i === 'radio' || i === 'checkbox' ? t(`input[name='${t(e).attr('name')}']:checked`).val() : typeof s === 'string' ? s.replace(/\r/g, '') : s; },
      check(e) { e = this.validationTargetFor(this.clean(e)); let i; const s = t(e).rules(); let r = !1; const n = this.elementValue(e); for (const a in s) { const u = { method: a, parameters: s[a] }; try { if (i = t.validator.methods[a].call(this, n, e, u.parameters), i === 'dependency-mismatch') { r = !0; continue; } if (r = !1, i === 'pending') return this.toHide = this.toHide.not(this.errorsFor(e)), void 0; if (!i) return this.formatAndAdd(e, u), !1; } catch (o) { throw this.settings.debug && window.console && console.log(`Exception occurred when checking element ${e.id}, check the '${u.method}' method.`, o), o; } } return r ? void 0 : (this.objectLength(s) && this.successList.push(e), !0); },
      customDataMessage(e, i) { return t(e).data(`msg-${i.toLowerCase()}`) || e.attributes && t(e).attr(`data-msg-${i.toLowerCase()}`); },
      customMessage(t, e) { const i = this.settings.messages[t]; return i && (i.constructor === String ? i : i[e]); },
      findDefined() { for (let t = 0; arguments.length > t; t++) if (void 0 !== arguments[t]) return arguments[t]; return void 0; },
      defaultMessage(e, i) { return this.findDefined(this.customMessage(e.name, i), this.customDataMessage(e, i), !this.settings.ignoreTitle && e.title || void 0, t.validator.messages[i], `<strong>Warning: No message defined for ${e.name}</strong>`); },
      formatAndAdd(e, i) { let s = this.defaultMessage(e, i.method); const r = /\$?\{(\d+)\}/g; typeof s === 'function' ? s = s.call(this, i.parameters, e) : r.test(s) && (s = t.validator.format(s.replace(r, '{$1}'), i.parameters)), this.errorList.push({ message: s, element: e }), this.errorMap[e.name] = s, this.submitted[e.name] = s; },
      addWrapper(t) { return this.settings.wrapper && (t = t.add(t.parent(this.settings.wrapper))), t; },
      defaultShowErrors() { let t; let e; for (t = 0; this.errorList[t]; t++) { const i = this.errorList[t]; this.settings.highlight && this.settings.highlight.call(this, i.element, this.settings.errorClass, this.settings.validClass), this.showLabel(i.element, i.message); } if (this.errorList.length && (this.toShow = this.toShow.add(this.containers)), this.settings.success) for (t = 0; this.successList[t]; t++) this.showLabel(this.successList[t]); if (this.settings.unhighlight) for (t = 0, e = this.validElements(); e[t]; t++) this.settings.unhighlight.call(this, e[t], this.settings.errorClass, this.settings.validClass); this.toHide = this.toHide.not(this.toShow), this.hideErrors(), this.addWrapper(this.toShow).show(); },
      validElements() { return this.currentElements.not(this.invalidElements()); },
      invalidElements() { return t(this.errorList).map(function () { return this.element; }); },
      showLabel(e, i) { let s = this.errorsFor(e); s.length ? (s.removeClass(this.settings.validClass).addClass(this.settings.errorClass), s.html(i)) : (s = t(`<${this.settings.errorElement}>`).attr('for', this.idOrName(e)).addClass(this.settings.errorClass).html(i || ''), this.settings.wrapper && (s = s.hide().show().wrap(`<${this.settings.wrapper}/>`).parent()), this.labelContainer.append(s).length || (this.settings.errorPlacement ? this.settings.errorPlacement(s, t(e)) : s.insertAfter(e))), !i && this.settings.success && (s.text(''), typeof this.settings.success === 'string' ? s.addClass(this.settings.success) : this.settings.success(s, e)), this.toShow = this.toShow.add(s); },
      errorsFor(e) { const i = this.idOrName(e); return this.errors().filter(function () { return t(this).attr('for') === i; }); },
      idOrName(t) { return this.groups[t.name] || (this.checkable(t) ? t.name : t.id || t.name); },
      validationTargetFor(t) { return this.checkable(t) && (t = this.findByName(t.name).not(this.settings.ignore)[0]), t; },
      checkable(t) { return /radio|checkbox/i.test(t.type); },
      findByName(e) { return t(this.currentForm).find(`[name='${e}']`); },
      getLength(e, i) { switch (i.nodeName.toLowerCase()) { case 'select': return t('option:selected', i).length; case 'input': if (this.checkable(i)) return this.findByName(i.name).filter(':checked').length; } return e.length; },
      depend(t, e) { return this.dependTypes[typeof t] ? this.dependTypes[typeof t](t, e) : !0; },
      dependTypes: { boolean(t) { return t; }, string(e, i) { return !!t(e, i.form).length; }, function(t, e) { return t(e); } },
      optional(e) { const i = this.elementValue(e); return !t.validator.methods.required.call(this, i, e) && 'dependency-mismatch'; },
      startRequest(t) { this.pending[t.name] || (this.pendingRequest++, this.pending[t.name] = !0); },
      stopRequest(e, i) { this.pendingRequest--, this.pendingRequest < 0 && (this.pendingRequest = 0), delete this.pending[e.name], i && this.pendingRequest === 0 && this.formSubmitted && this.form() ? (t(this.currentForm).submit(), this.formSubmitted = !1) : !i && this.pendingRequest === 0 && this.formSubmitted && (t(this.currentForm).triggerHandler('invalid-form', [this]), this.formSubmitted = !1); },
      previousValue(e) { return t.data(e, 'previousValue') || t.data(e, 'previousValue', { old: null, valid: !0, message: this.defaultMessage(e, 'remote') }); },
    },
    classRuleSettings: {
      required: { required: !0 }, email: { email: !0 }, url: { url: !0 }, date: { date: !0 }, dateISO: { dateISO: !0 }, number: { number: !0 }, digits: { digits: !0 }, creditcard: { creditcard: !0 },
    },
    addClassRules(e, i) { e.constructor === String ? this.classRuleSettings[e] = i : t.extend(this.classRuleSettings, e); },
    classRules(e) { const i = {}; const s = t(e).attr('class'); return s && t.each(s.split(' '), function () { this in t.validator.classRuleSettings && t.extend(i, t.validator.classRuleSettings[this]); }), i; },
    attributeRules(e) { const i = {}; const s = t(e); const r = s[0].getAttribute('type'); for (const n in t.validator.methods) { var a; n === 'required' ? (a = s.get(0).getAttribute(n), a === '' && (a = !0), a = !!a) : a = s.attr(n), /min|max/.test(n) && (r === null || /number|range|text/.test(r)) && (a = Number(a)), a ? i[n] = a : r === n && r !== 'range' && (i[n] = !0); } return i.maxlength && /-1|2147483647|524288/.test(i.maxlength) && delete i.maxlength, i; },
    dataRules(e) { let i; let s; const r = {}; const n = t(e); for (i in t.validator.methods)s = n.data(`rule-${i.toLowerCase()}`), void 0 !== s && (r[i] = s); return r; },
    staticRules(e) { let i = {}; const s = t.data(e.form, 'validator'); return s.settings.rules && (i = t.validator.normalizeRule(s.settings.rules[e.name]) || {}), i; },
    normalizeRules(e, i) { return t.each(e, (s, r) => { if (r === !1) return delete e[s], void 0; if (r.param || r.depends) { let n = !0; switch (typeof r.depends) { case 'string': n = !!t(r.depends, i.form).length; break; case 'function': n = r.depends.call(i, i); }n ? e[s] = void 0 !== r.param ? r.param : !0 : delete e[s]; } }), t.each(e, (s, r) => { e[s] = t.isFunction(r) ? r(i) : r; }), t.each(['minlength', 'maxlength'], function () { e[this] && (e[this] = Number(e[this])); }), t.each(['rangelength', 'range'], function () { let i; e[this] && (t.isArray(e[this]) ? e[this] = [Number(e[this][0]), Number(e[this][1])] : typeof e[this] === 'string' && (i = e[this].split(/[\s,]+/), e[this] = [Number(i[0]), Number(i[1])])); }), t.validator.autoCreateRanges && (e.min && e.max && (e.range = [e.min, e.max], delete e.min, delete e.max), e.minlength && e.maxlength && (e.rangelength = [e.minlength, e.maxlength], delete e.minlength, delete e.maxlength)), e; },
    normalizeRule(e) { if (typeof e === 'string') { const i = {}; t.each(e.split(/\s/), function () { i[this] = !0; }), e = i; } return e; },
    addMethod(e, i, s) { t.validator.methods[e] = i, t.validator.messages[e] = void 0 !== s ? s : t.validator.messages[e], i.length < 3 && t.validator.addClassRules(e, t.validator.normalizeRule(e)); },
    methods: {
      required(e, i, s) { if (!this.depend(s, i)) return 'dependency-mismatch'; if (i.nodeName.toLowerCase() === 'select') { const r = t(i).val(); return r && r.length > 0; } return this.checkable(i) ? this.getLength(e, i) > 0 : t.trim(e).length > 0; },
      email(t, e) { return this.optional(e) || /^((([a-z]|\d|[!#\$%&'\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+(\.([a-z]|\d|[!#\$%&'\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+)*)|((\x22)((((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(([\x01-\x08\x0b\x0c\x0e-\x1f\x7f]|\x21|[\x23-\x5b]|[\x5d-\x7e]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(\\([\x01-\x09\x0b\x0c\x0d-\x7f]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]))))*(((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(\x22)))@((([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.)+(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))$/i.test(t); },
      url(t, e) { return this.optional(e) || /^(https?|s?ftp):\/\/(((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:)*@)?(((\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5]))|((([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.)+(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.?)(:\d*)?)(\/((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)+(\/(([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)*)*)?)?(\?((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)|[\uE000-\uF8FF]|\/|\?)*)?(#((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)|\/|\?)*)?$/i.test(t); },
      date(t, e) { return this.optional(e) || !/Invalid|NaN/.test(`${new Date(t)}`); },
      dateISO(t, e) { return this.optional(e) || /^\d{4}[\/\-]\d{1,2}[\/\-]\d{1,2}$/.test(t); },
      number(t, e) { return this.optional(e) || /^-?(?:\d+|\d{1,3}(?:,\d{3})+)?(?:\.\d+)?$/.test(t); },
      digits(t, e) { return this.optional(e) || /^\d+$/.test(t); },
      creditcard(t, e) { if (this.optional(e)) return 'dependency-mismatch'; if (/[^0-9 \-]+/.test(t)) return !1; let i = 0; let s = 0; let r = !1; t = t.replace(/\D/g, ''); for (let n = t.length - 1; n >= 0; n--) { const a = t.charAt(n); s = parseInt(a, 10), r && (s *= 2) > 9 && (s -= 9), i += s, r = !r; } return i % 10 === 0; },
      minlength(e, i, s) { const r = t.isArray(e) ? e.length : this.getLength(t.trim(e), i); return this.optional(i) || r >= s; },
      maxlength(e, i, s) { const r = t.isArray(e) ? e.length : this.getLength(t.trim(e), i); return this.optional(i) || s >= r; },
      rangelength(e, i, s) { const r = t.isArray(e) ? e.length : this.getLength(t.trim(e), i); return this.optional(i) || r >= s[0] && s[1] >= r; },
      min(t, e, i) { return this.optional(e) || t >= i; },
      max(t, e, i) { return this.optional(e) || i >= t; },
      range(t, e, i) { return this.optional(e) || t >= i[0] && i[1] >= t; },
      equalTo(e, i, s) { const r = t(s); return this.settings.onfocusout && r.unbind('.validate-equalTo').bind('blur.validate-equalTo', () => { t(i).valid(); }), e === r.val(); },
      remote(e, i, s) {
        if (this.optional(i)) return 'dependency-mismatch'; const r = this.previousValue(i); if (this.settings.messages[i.name] || (this.settings.messages[i.name] = {}), r.originalMessage = this.settings.messages[i.name].remote, this.settings.messages[i.name].remote = r.message, s = typeof s === 'string' && { url: s } || s, r.old === e) return r.valid; r.old = e; const n = this; this.startRequest(i); const a = {}; return a[i.name] = e, t.ajax(t.extend(!0, {
          url: s, mode: 'abort', port: `validate${i.name}`, dataType: 'json', data: a, success(s) { n.settings.messages[i.name].remote = r.originalMessage; const a = s === !0 || s === 'true'; if (a) { const u = n.formSubmitted; n.prepareElement(i), n.formSubmitted = u, n.successList.push(i), delete n.invalid[i.name], n.showErrors(); } else { const o = {}; const l = s || n.defaultMessage(i, 'remote'); o[i.name] = r.message = t.isFunction(l) ? l(e) : l, n.invalid[i.name] = !0, n.showErrors(o); }r.valid = a, n.stopRequest(i, a); },
        }, s)), 'pending';
      },
    },
  }), t.format = t.validator.format;
}(jQuery)), (function (t) { const e = {}; if (t.ajaxPrefilter)t.ajaxPrefilter((t, i, s) => { const r = t.port; t.mode === 'abort' && (e[r] && e[r].abort(), e[r] = s); }); else { const i = t.ajax; t.ajax = function (s) { const r = ('mode' in s ? s : t.ajaxSettings).mode; const n = ('port' in s ? s : t.ajaxSettings).port; return r === 'abort' ? (e[n] && e[n].abort(), e[n] = i.apply(this, arguments), e[n]) : i.apply(this, arguments); }; } }(jQuery)), (function (t) { t.extend(t.fn, { validateDelegate(e, i, s) { return this.bind(i, function (i) { const r = t(i.target); return r.is(e) ? s.apply(r, arguments) : void 0; }); } }); }(jQuery));
