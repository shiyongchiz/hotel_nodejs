/*! Stellar.js v0.6.2 | Copyright 2013, Mark Dalgleish | http://markdalgleish.com/projects/stellar.js | http://markdalgleish.mit-license.org */
(function (e, t, n, r) {
  function d(t, n) { this.element = t, this.options = e.extend({}, s, n), this._defaults = s, this._name = i, this.init(); } var i = 'stellar'; var s = {
    scrollProperty: 'scroll', positionProperty: 'position', horizontalScrolling: !0, verticalScrolling: !0, horizontalOffset: 0, verticalOffset: 0, responsive: !1, parallaxBackgrounds: !0, parallaxElements: !0, hideDistantElements: !0, hideElement(e) { e.hide(); }, showElement(e) { e.show(); },
  }; const o = {
    scroll: {
      getLeft(e) { return e.scrollLeft(); }, setLeft(e, t) { e.scrollLeft(t); }, getTop(e) { return e.scrollTop(); }, setTop(e, t) { e.scrollTop(t); },
    },
    position: { getLeft(e) { return parseInt(e.css('left'), 10) * -1; }, getTop(e) { return parseInt(e.css('top'), 10) * -1; } },
    margin: { getLeft(e) { return parseInt(e.css('margin-left'), 10) * -1; }, getTop(e) { return parseInt(e.css('margin-top'), 10) * -1; } },
    transform: { getLeft(e) { const t = getComputedStyle(e[0])[f]; return t !== 'none' ? parseInt(t.match(/(-?[0-9]+)/g)[4], 10) * -1 : 0; }, getTop(e) { const t = getComputedStyle(e[0])[f]; return t !== 'none' ? parseInt(t.match(/(-?[0-9]+)/g)[5], 10) * -1 : 0; } },
  }; const u = { position: { setLeft(e, t) { e.css('left', t); }, setTop(e, t) { e.css('top', t); } }, transform: { setPosition(e, t, n, r, i) { e[0].style[f] = `translate3d(${t - n}px, ${r - i}px, 0)`; } } }; const a = (function () { const t = /^(Moz|Webkit|Khtml|O|ms|Icab)(?=[A-Z])/; const n = e('script')[0].style; let r = ''; let i; for (i in n) if (t.test(i)) { r = i.match(t)[0]; break; } return 'WebkitOpacity' in n && (r = 'Webkit'), 'KhtmlOpacity' in n && (r = 'Khtml'), function (e) { return r + (r.length > 0 ? e.charAt(0).toUpperCase() + e.slice(1) : e); }; }()); var f = a('transform'); const l = e('<div />', { style: 'background:#fff' }).css('background-position-x') !== r; const c = l ? function (e, t, n) { e.css({ 'background-position-x': t, 'background-position-y': n }); } : function (e, t, n) { e.css('background-position', `${t} ${n}`); }; const h = l ? function (e) { return [e.css('background-position-x'), e.css('background-position-y')]; } : function (e) { return e.css('background-position').split(' '); }; const p = t.requestAnimationFrame || t.webkitRequestAnimationFrame || t.mozRequestAnimationFrame || t.oRequestAnimationFrame || t.msRequestAnimationFrame || function (e) { setTimeout(e, 1e3 / 60); }; d.prototype = {
    init() { this.options.name = `${i}_${Math.floor(Math.random() * 1e9)}`, this._defineElements(), this._defineGetters(), this._defineSetters(), this._handleWindowLoadAndResize(), this._detectViewport(), this.refresh({ firstLoad: !0 }), this.options.scrollProperty === 'scroll' ? this._handleScrollEvent() : this._startAnimationLoop(); },
    _defineElements() { this.element === n.body && (this.element = t), this.$scrollElement = e(this.element), this.$element = this.element === t ? e('body') : this.$scrollElement, this.$viewportElement = this.options.viewportElement !== r ? e(this.options.viewportElement) : this.$scrollElement[0] === t || this.options.scrollProperty === 'scroll' ? this.$scrollElement : this.$scrollElement.parent(); },
    _defineGetters() { const e = this; const t = o[e.options.scrollProperty]; this._getScrollLeft = function () { return t.getLeft(e.$scrollElement); }, this._getScrollTop = function () { return t.getTop(e.$scrollElement); }; },
    _defineSetters() { const t = this; const n = o[t.options.scrollProperty]; const r = u[t.options.positionProperty]; const i = n.setLeft; const s = n.setTop; this._setScrollLeft = typeof i === 'function' ? function (e) { i(t.$scrollElement, e); } : e.noop, this._setScrollTop = typeof s === 'function' ? function (e) { s(t.$scrollElement, e); } : e.noop, this._setPosition = r.setPosition || function (e, n, i, s, o) { t.options.horizontalScrolling && r.setLeft(e, n, i), t.options.verticalScrolling && r.setTop(e, s, o); }; },
    _handleWindowLoadAndResize() { const n = this; const r = e(t); n.options.responsive && r.bind(`load.${this.name}`, () => { n.refresh(); }), r.bind(`resize.${this.name}`, () => { n._detectViewport(), n.options.responsive && n.refresh(); }); },
    refresh(n) { const r = this; const i = r._getScrollLeft(); const s = r._getScrollTop(); (!n || !n.firstLoad) && this._reset(), this._setScrollLeft(0), this._setScrollTop(0), this._setOffsets(), this._findParticles(), this._findBackgrounds(), n && n.firstLoad && /WebKit/.test(navigator.userAgent) && e(t).load(() => { const e = r._getScrollLeft(); const t = r._getScrollTop(); r._setScrollLeft(e + 1), r._setScrollTop(t + 1), r._setScrollLeft(e), r._setScrollTop(t); }), this._setScrollLeft(i), this._setScrollTop(s); },
    _detectViewport() { const e = this.$viewportElement.offset(); const t = e !== null && e !== r; this.viewportWidth = this.$viewportElement.width(), this.viewportHeight = this.$viewportElement.height(), this.viewportOffsetTop = t ? e.top : 0, this.viewportOffsetLeft = t ? e.left : 0; },
    _findParticles() {
      const t = this; const n = this._getScrollLeft(); const i = this._getScrollTop(); if (this.particles !== r) for (let s = this.particles.length - 1; s >= 0; s--) this.particles[s].$element.data('stellar-elementIsActive', r); this.particles = []; if (!this.options.parallaxElements) return; this.$element.find('[data-stellar-ratio]').each(function (n) {
        const i = e(this); let s; let o; let u; let a; let f; let l; let c; let h; let p; let d = 0; let v = 0; let m = 0; let g = 0; if (!i.data('stellar-elementIsActive'))i.data('stellar-elementIsActive', this); else if (i.data('stellar-elementIsActive') !== this) return; t.options.showElement(i), i.data('stellar-startingLeft') ? (i.css('left', i.data('stellar-startingLeft')), i.css('top', i.data('stellar-startingTop'))) : (i.data('stellar-startingLeft', i.css('left')), i.data('stellar-startingTop', i.css('top'))), u = i.position().left, a = i.position().top, f = i.css('margin-left') === 'auto' ? 0 : parseInt(i.css('margin-left'), 10), l = i.css('margin-top') === 'auto' ? 0 : parseInt(i.css('margin-top'), 10), h = i.offset().left - f, p = i.offset().top - l, i.parents().each(function () { const t = e(this); if (t.data('stellar-offset-parent') === !0) return d = m, v = g, c = t, !1; m += t.position().left, g += t.position().top; }), s = i.data('stellar-horizontal-offset') !== r ? i.data('stellar-horizontal-offset') : c !== r && c.data('stellar-horizontal-offset') !== r ? c.data('stellar-horizontal-offset') : t.horizontalOffset, o = i.data('stellar-vertical-offset') !== r ? i.data('stellar-vertical-offset') : c !== r && c.data('stellar-vertical-offset') !== r ? c.data('stellar-vertical-offset') : t.verticalOffset, t.particles.push({
          $element: i, $offsetParent: c, isFixed: i.css('position') === 'fixed', horizontalOffset: s, verticalOffset: o, startingPositionLeft: u, startingPositionTop: a, startingOffsetLeft: h, startingOffsetTop: p, parentOffsetLeft: d, parentOffsetTop: v, stellarRatio: i.data('stellar-ratio') !== r ? i.data('stellar-ratio') : 1, width: i.outerWidth(!0), height: i.outerHeight(!0), isHidden: !1,
        });
      });
    },
    _findBackgrounds() {
      const t = this; const n = this._getScrollLeft(); const i = this._getScrollTop(); let s; this.backgrounds = []; if (!this.options.parallaxBackgrounds) return; s = this.$element.find('[data-stellar-background-ratio]'), this.$element.data('stellar-background-ratio') && (s = s.add(this.$element)), s.each(function () {
        const s = e(this); const o = h(s); let u; let a; let f; let l; let p; let d; let v; let m; let g; let y = 0; let b = 0; let w = 0; let E = 0; if (!s.data('stellar-backgroundIsActive'))s.data('stellar-backgroundIsActive', this); else if (s.data('stellar-backgroundIsActive') !== this) return; s.data('stellar-backgroundStartingLeft') ? c(s, s.data('stellar-backgroundStartingLeft'), s.data('stellar-backgroundStartingTop')) : (s.data('stellar-backgroundStartingLeft', o[0]), s.data('stellar-backgroundStartingTop', o[1])), p = s.css('margin-left') === 'auto' ? 0 : parseInt(s.css('margin-left'), 10), d = s.css('margin-top') === 'auto' ? 0 : parseInt(s.css('margin-top'), 10), v = s.offset().left - p - n, m = s.offset().top - d - i, s.parents().each(function () { const t = e(this); if (t.data('stellar-offset-parent') === !0) return y = w, b = E, g = t, !1; w += t.position().left, E += t.position().top; }), u = s.data('stellar-horizontal-offset') !== r ? s.data('stellar-horizontal-offset') : g !== r && g.data('stellar-horizontal-offset') !== r ? g.data('stellar-horizontal-offset') : t.horizontalOffset, a = s.data('stellar-vertical-offset') !== r ? s.data('stellar-vertical-offset') : g !== r && g.data('stellar-vertical-offset') !== r ? g.data('stellar-vertical-offset') : t.verticalOffset, t.backgrounds.push({
          $element: s, $offsetParent: g, isFixed: s.css('background-attachment') === 'fixed', horizontalOffset: u, verticalOffset: a, startingValueLeft: o[0], startingValueTop: o[1], startingBackgroundPositionLeft: isNaN(parseInt(o[0], 10)) ? 0 : parseInt(o[0], 10), startingBackgroundPositionTop: isNaN(parseInt(o[1], 10)) ? 0 : parseInt(o[1], 10), startingPositionLeft: s.position().left, startingPositionTop: s.position().top, startingOffsetLeft: v, startingOffsetTop: m, parentOffsetLeft: y, parentOffsetTop: b, stellarRatio: s.data('stellar-background-ratio') === r ? 1 : s.data('stellar-background-ratio'),
        });
      });
    },
    _reset() { let e; let t; let n; let r; let i; for (i = this.particles.length - 1; i >= 0; i--)e = this.particles[i], t = e.$element.data('stellar-startingLeft'), n = e.$element.data('stellar-startingTop'), this._setPosition(e.$element, t, t, n, n), this.options.showElement(e.$element), e.$element.data('stellar-startingLeft', null).data('stellar-elementIsActive', null).data('stellar-backgroundIsActive', null); for (i = this.backgrounds.length - 1; i >= 0; i--)r = this.backgrounds[i], r.$element.data('stellar-backgroundStartingLeft', null).data('stellar-backgroundStartingTop', null), c(r.$element, r.startingValueLeft, r.startingValueTop); },
    destroy() { this._reset(), this.$scrollElement.unbind(`resize.${this.name}`).unbind(`scroll.${this.name}`), this._animationLoop = e.noop, e(t).unbind(`load.${this.name}`).unbind(`resize.${this.name}`); },
    _setOffsets() { const n = this; const r = e(t); r.unbind(`resize.horizontal-${this.name}`).unbind(`resize.vertical-${this.name}`), typeof this.options.horizontalOffset === 'function' ? (this.horizontalOffset = this.options.horizontalOffset(), r.bind(`resize.horizontal-${this.name}`, () => { n.horizontalOffset = n.options.horizontalOffset(); })) : this.horizontalOffset = this.options.horizontalOffset, typeof this.options.verticalOffset === 'function' ? (this.verticalOffset = this.options.verticalOffset(), r.bind(`resize.vertical-${this.name}`, () => { n.verticalOffset = n.options.verticalOffset(); })) : this.verticalOffset = this.options.verticalOffset; },
    _repositionElements() { const e = this._getScrollLeft(); const t = this._getScrollTop(); let n; let r; let i; let s; let o; let u; let a; let f = !0; let l = !0; let h; let p; let d; let v; let m; if (this.currentScrollLeft === e && this.currentScrollTop === t && this.currentWidth === this.viewportWidth && this.currentHeight === this.viewportHeight) return; this.currentScrollLeft = e, this.currentScrollTop = t, this.currentWidth = this.viewportWidth, this.currentHeight = this.viewportHeight; for (m = this.particles.length - 1; m >= 0; m--)i = this.particles[m], s = i.isFixed ? 1 : 0, this.options.horizontalScrolling ? (h = (e + i.horizontalOffset + this.viewportOffsetLeft + i.startingPositionLeft - i.startingOffsetLeft + i.parentOffsetLeft) * -(i.stellarRatio + s - 1) + i.startingPositionLeft, d = h - i.startingPositionLeft + i.startingOffsetLeft) : (h = i.startingPositionLeft, d = i.startingOffsetLeft), this.options.verticalScrolling ? (p = (t + i.verticalOffset + this.viewportOffsetTop + i.startingPositionTop - i.startingOffsetTop + i.parentOffsetTop) * -(i.stellarRatio + s - 1) + i.startingPositionTop, v = p - i.startingPositionTop + i.startingOffsetTop) : (p = i.startingPositionTop, v = i.startingOffsetTop), this.options.hideDistantElements && (l = !this.options.horizontalScrolling || d + i.width > (i.isFixed ? 0 : e) && d < (i.isFixed ? 0 : e) + this.viewportWidth + this.viewportOffsetLeft, f = !this.options.verticalScrolling || v + i.height > (i.isFixed ? 0 : t) && v < (i.isFixed ? 0 : t) + this.viewportHeight + this.viewportOffsetTop), l && f ? (i.isHidden && (this.options.showElement(i.$element), i.isHidden = !1), this._setPosition(i.$element, h, i.startingPositionLeft, p, i.startingPositionTop)) : i.isHidden || (this.options.hideElement(i.$element), i.isHidden = !0); for (m = this.backgrounds.length - 1; m >= 0; m--)o = this.backgrounds[m], s = o.isFixed ? 0 : 1, u = this.options.horizontalScrolling ? `${(e + o.horizontalOffset - this.viewportOffsetLeft - o.startingOffsetLeft + o.parentOffsetLeft - o.startingBackgroundPositionLeft) * (s - o.stellarRatio)}px` : o.startingValueLeft, a = this.options.verticalScrolling ? `${(t + o.verticalOffset - this.viewportOffsetTop - o.startingOffsetTop + o.parentOffsetTop - o.startingBackgroundPositionTop) * (s - o.stellarRatio)}px` : o.startingValueTop, c(o.$element, u, a); },
    _handleScrollEvent() { const e = this; let t = !1; const n = function () { e._repositionElements(), t = !1; }; const r = function () { t || (p(n), t = !0); }; this.$scrollElement.bind(`scroll.${this.name}`, r), r(); },
    _startAnimationLoop() { const e = this; this._animationLoop = function () { p(e._animationLoop), e._repositionElements(); }, this._animationLoop(); },
  }, e.fn[i] = function (t) { const n = arguments; if (t === r || typeof t === 'object') return this.each(function () { e.data(this, `plugin_${i}`) || e.data(this, `plugin_${i}`, new d(this, t)); }); if (typeof t === 'string' && t[0] !== '_' && t !== 'init') return this.each(function () { const r = e.data(this, `plugin_${i}`); r instanceof d && typeof r[t] === 'function' && r[t].apply(r, Array.prototype.slice.call(n, 1)), t === 'destroy' && e.data(this, `plugin_${i}`, null); }); }, e[i] = function (n) { const r = e(t); return r.stellar.apply(r, Array.prototype.slice.call(arguments, 0)); }, e[i].scrollProperty = o, e[i].positionProperty = u, t.Stellar = d;
}(jQuery, this, document));

/** !
 * @author odahcam
 * @see The boilerplate used here was https://github.com/odahcam/jQueryPlugin-Boilerplate
 * @external https://github.com/odahcam/jquery.parallax/
 */

/**
 * @param {object} $
 * @param {object} window
 * @param {object} document
 * @param {undefined} undefined
 * @return
 */
(function (d, f, g, b) {
  if (!d) { console.error('jQuery nÃ£o encontrado, seu plugin jQuery nÃ£o irÃ¡ funcionar.'); return false; }(function () { let k = 0; const l = ['ms', 'moz', 'webkit', 'o']; for (let j = 0; j < l.length && !f.requestAnimationFrame; ++j) { f.requestAnimationFrame = f[`${l[j]}RequestAnimationFrame`]; f.cancelAnimationFrame = f[`${l[j]}CancelAnimationFrame`] || f[`${l[j]}CancelRequestAnimationFrame`]; } if (!f.requestAnimationFrame) { f.requestAnimationFrame = function (q, n) { const m = new Date().getTime(); const o = Math.max(0, 16 - (m - k)); const p = f.setTimeout(() => { q(m + o); }, o); k = m + o; return p; }; } if (!f.cancelAnimationFrame) { f.cancelAnimationFrame = function (m) { clearTimeout(m); }; } }()); const e = 'parallax'; const c = { on: 'scroll', listenTo: f, sceneMode: false }; const a = d(f); let i = 0; function h(k, j) { this._name = e; this._instance_id = ++i; this.el = k; this.$el = d(k); this.settings = d.extend(false, {}, c, j, this.$el.data()); this.$triggerOrigin = d(this.settings.listenTo); this.init(); }d.extend(h.prototype, {
    init() { const j = this; this.$triggerOrigin.on(`${j.settings.on}.${j._name}`, () => { j.parallaxTranslate(); }); j.parallaxTranslate(); }, parallaxTranslate() { const j = this; if (j.inScreen()) { f.requestAnimationFrame(() => { const k = a.scrollTop() - j.$el.offset().top; j.$el.css('transform', `translateY(${k / 2}px)`); }); }console.groupEnd(); }, destroy() { this.$el.removeData(); d(this.settings.listenTo).off(`.${e}`); }, somePublicMethod(k, j) { privateMethod.call(this); }, inScreen(l) { let o; if (typeof l !== 'boolean' && l !== b) { o = d(l); l = arguments[1] || false; } else { o = this.$el; l = l || false; } const k = a.scrollTop(); const n = k + a.height(); const j = o.offset().top; const m = j + o.height(); if (l === true) { return k <= j && n >= m; } return !(k > m || n < j); },
  }); d.fn[e] = function (k) { const j = arguments; if (k === b || typeof k === 'object') { return this.each(function () { if (!d.data(this, `plugin_${e}`)) { d.data(this, `plugin_${e}`, new h(this, k)); } }); } if (typeof k === 'string' && k !== 'init') { return this.each(function () { const l = d.data(this, `plugin_${e}`); if (l instanceof h && typeof l[k] === 'function') { l[k].apply(l, Array.prototype.slice.call(j, 1)); } }); } };
}(window.jQuery || false, window, document));
